# Queue with two stacks

## Why?

자바스크립트에서는 Array 메서드인 shift와 pop으로 쉽게 queue를 구현할 수 있다. 하지만 Array의 특성상 shift를 했을 때 내부에 있는 데이터가 모두 이동(각각의 데이터를 왼쪽으로 한 번 씩 옮겨야 한다)을 해야하고, 따라서 데이터의 크기가 큰 경우 굉장히 비효율적이다. 이런 문제를 완화하기 위해 **두 개의 스택**으로 queue를 구현한다.

## Queue

queue는 FIFO(First In First Out), 즉 먼저 들어간 친구가 먼저 나오는 형태이다. 대기 줄을 생각하면 이해하기가 쉽다. 들어온 순서대로 나간다.

## 첫 번째 시도

dequeue를 어떻게 구현하느냐가 관건이라고 생각했다. 만약 배열에 [1, 2, 3]이 들어갔다고 가정했을 때, dequeue를 하면 1이 나와야 한다.

1. 첫 번째 스택에 enqueue(push로 구현)를 통해 [1, 2, 3]이 들어갔다고 가정했다.
2. 이제 dequeue를 하기 위해, 우리가 필요한 1을 제외한 값을 전부 pop()하고 두 번째 스택에 push() 한다.
3. 첫 번째 스택에 남은 1도 pop()한다.
4. 두 번째 스택에 있는 값을 pop()해서 다시 첫 번째 스택에 push() 한다.
5. dequeue의 결과로 1을 제외한 값이 스택에 쌓이게 된다.
6. 나중에 생각해보니까 dequeue는 값을 리턴해야 한다는 것을 깨달았다😅


## 첫 번째 시도에서 놓친 점

1. 배열의 길이가 0일 경우, 무한 루프를 돌게 된다.
2. 두 번째 배열에 옮겨 놓고, 첫 번째 배열에 또 다시 옮기는 형태라 비효율적이었다.
3. 리턴을 생각하지 못했다😅

## 두 번째 시도

처음 push한 배열에서 다른 배열로 옮기고, 옮긴 배열에서 원하는 원소를 추출하도록 개선했다.

1. 첫 번째 스택에 똑같이 enqueue를 통해 [1, 2, 3]의 형태로 만든다.
2. dequeue를 하면 첫 번째 스택에 있는 값을 전부 pop()해서 두 번째 스택에 push() 한다.
   1. 두 번째 스택의 길이는 0이고 첫 번째 스택은 하나 이상의 원소가 쌓여있는 조건을 추가한다.
   2. 이미 두 번째 스택에 값이 들어있다면, 바로 pop()을 해서 결과를 리턴한다.
3. 두 번째 스택은 [3, 2, 1]의 형태가 된다.
4. 이제 두 번째 스택에서 pop()을 한 결과를 리턴하면 맨 처음 들어갔던 1을 추출할 수 있다.